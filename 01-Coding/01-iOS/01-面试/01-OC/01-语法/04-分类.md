# 1. 基本使用
1. xcode创建分类文件
```objc
import "Person+Run.h"

@implementaition Person(Run)

- (void)slow {
	NSLog(@"slow");
}
```

# 2. 本质
 1. 分类的本质是结构体
 2. 程序编译时通过运行时将该结构体合并到类中
## 2.1 底层结构
```objc
struct _category_t {
	/// 类名
	const char *name;
	/// 类
	classref_t cls;
	/// 对象方法列表
	struct method_list_t *instanceMethods;
	/// 类方法列表
	struct method_list_t *classMethods;
	/// 协议列表
	struct protocol_list_t *protocols;
	/// 属性列表
	struct property_list_t *instanceProperties;
	/// 类属性
	struct property_list_t *_classProperties;

	/// 取出分类中的对象方法或类方法
	/// isMeta 是否是元类
	method_list_t *methodsForMeta(bool isMeta) {
		if (isMeta) return classMethods;
		else return instanceMethods;
	}
	
	property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);
};
```

## 2.2 加载过程
![微信图片_20241214143620.png](https://raw.githubusercontent.com/627969687/LevelUp/main/resource/202412141437902.png)

# 3. load方法
## 3.1 基本使用
1. load方法是runtime加载类和分类时调用
2. 程序运行过程中只调用一次
3. 调用顺序与编译顺序一致（类本身的load方法第一个调用）
```objc
/// 分类
#import "Person+Test1.h"

@implementation Person (Test1)
+ (void)load {
    NSLog(@"Person (Test1) +load");
}

/// 类
#import "Person.h"

@implementation Person
+ (void)load {
	NSLog(@"Person load");
}
@end
```

## 3.2 调用原理
runtime中的实现代码
```objc
/// 定义了一个结构体保存所有类的load方法
struct loadable_class {
	Class cls; // may be nil
	IMP method; // 所有load方法
}

/// 定义了一个结构体保存所有分类的load方法
struct loadable_category {
	Category cat; // may be nil
	IMP method;
}

/// 调用类的load方法
static void call_class_loads(void) {
	int i;

	// Detach current loadable list.
	struct loadable_class *classes = loadable_classes;
	int used = loadble_classes_used;
	loadable_classes = nil;
	loadable_classes_allocated = 0;
	loadable_classes_used = 0;

	// Call all +loads for the detached list.
	for (i = 0; i < used; i++) {
		Class cls = classes[i].cls;
		load_method_t load_method = (load_method_t)classes[i].method;
		if (!cls) continue;
		if (PrintLoading) {
			_objc_inform("LOAD: +[%s load]\n", cls->nameForLogging());
			(*load_method)(cls, SEL_load);
		}
	}

	// Destroy the detached list.
	if (classes) free(classes);
}

/// 调用分类的load方法
static void call_category_loads(void) {
	...
}

/// 调用所有的load方法
void call_load_methods(void) {
	static bool loading = NO;
	bool more_categories;

	loadMethodLock.assertLocked();

	if (loading) return;
	loading = YES;

	void *pool = objc_autoreleasePoolPush();

	do {
		// 1.Repeatedly call class +loads until there aren't any more
		while (loadable_classes_used > 0) {
			call_class_loads();
		}

		// 2.Call category +loads ONCE
		more_categories = call_category_loads();

		// 3.Run more +loads if there are classes OR more untried categories
	} while (loadable_classes_used > 0 || more_categories);

	objc_autoreleasePoolPop(pool);
	loading = NO;
}
```


# 3. 分类和类扩展
```objc
#import "Person.h"

// class extension (匿名分类\类扩展)
@interface Person()
@property (nonatomic, assign) int age;
- (void)run;
@end

@implementation MJPerson
@end
```
区别：
1. 类扩展在.m文件内实现，只是没有暴露到.h文件；所以在编辑的时候，数据已经包含在类信息中
2. 分类是在运行时通过runtime合并到类信息中

优劣：
1. 分类

| 优       | 劣                                               |
| :------ | :---------------------------------------------- |
| 入侵性少    | 无法调用私有方法属性                                      |
| 可以扩展系统类 | 同名方法会被分类替换为最后一个分类中的方法（参考分类数组的顺序，load方法之类的不会被替换） |
2. 扩展

| 优       | 劣     |
| :------ | :---- |
| 避免了命名冲突 | 无法被继承 |
