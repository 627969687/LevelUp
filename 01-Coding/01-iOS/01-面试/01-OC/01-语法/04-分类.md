# 1. 基本使用
1. xcode创建分类文件
```objc
import "Person+Run.h"

@implementaition Person(Run)

- (void)slow {
	NSLog(@"slow");
}
```

# 2. 本质
 1. 分类的本质是结构体
 2. 程序编译时通过运行时将该结构体合并到类中
## 2.1 底层结构
```objc
struct _category_t {
	/// 类名
	const char *name;
	/// 类
	classref_t cls;
	/// 对象方法列表
	struct method_list_t *instanceMethods;
	/// 类方法列表
	struct method_list_t *classMethods;
	/// 协议列表
	struct protocol_list_t *protocols;
	/// 属性列表
	struct property_list_t *instanceProperties;
	/// 类属性
	struct property_list_t *_classProperties;

	/// 取出分类中的对象方法或类方法
	/// isMeta 是否是元类
	method_list_t *methodsForMeta(bool isMeta) {
		if (isMeta) return classMethods;
		else return instanceMethods;
	}
	
	property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);
};
```

## 2.2 加载过程
![微信图片_20241214143620.png](https://raw.githubusercontent.com/627969687/LevelUp/main/resource/202412141437902.png)

# 3. load方法
## 3.1 基本使用
1. load方法是runtime加载类和分类时调用
2. 程序运行过程中只调用一次
3. 调用顺序与编译顺序一致（类本身的load方法第一个调用）
```objc
/// 分类
#import "Person+Test1.h"

@implementation Person (Test1)
+ (void)load {
    NSLog(@"Person (Test1) +load");
}

/// 类
#import "Person.h"

@implementation Person
+ (void)load {
	NSLog(@"Person load");
}
@end
```

## 3.2 调用原理


# 3. 分类和类扩展
```objc
#import "Person.h"

// class extension (匿名分类\类扩展)
@interface Person()
@property (nonatomic, assign) int age;
- (void)run;
@end

@implementation MJPerson
@end
```
区别：
1. 类扩展在.m文件内实现，只是没有暴露到.h文件；所以在编辑的时候，数据已经包含在类信息中
2. 分类是在运行时通过runtime合并到类信息中

优劣：
1. 分类

| 优       | 劣                                               |
| :------ | :---------------------------------------------- |
| 入侵性少    | 无法调用私有方法属性                                      |
| 可以扩展系统类 | 同名方法会被分类替换为最后一个分类中的方法（参考分类数组的顺序，load方法之类的不会被替换） |
2. 扩展

| 优       | 劣     |
| :------ | :---- |
| 避免了命名冲突 | 无法被继承 |
